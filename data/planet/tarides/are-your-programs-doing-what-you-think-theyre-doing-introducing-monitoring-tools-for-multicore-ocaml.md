---
title: Are Your Programs Doing What You Think They're Doing? Introducing Monitoring
  Tools for Multicore OCaml
description: Exploring OCaml 5's runtime monitoring with `runtime_events` for efficient
  performance insights. Learn about custom events, ring buffers, and tools like Olly.
url: https://tarides.com/blog/2024-01-31-are-your-programs-doing-what-you-think-they-re-doing-introducing-monitoring-tools-for-multicore-ocaml
date: 2024-01-31T00:00:00-00:00
preview_image: https://tarides.com/blog/images/monitoring_desk-1360w.webp
featured:
authors:
- Tarides
source:
---

<p>As programs grow in size and complexity, they become more challenging to optimise. When the cause of a particular performance issue can theoretically be attributed to multiple sources, developers need concrete data to drive their decision making and avoid time-consuming guesswork. As you can imagine, OCaml 5&rsquo;s new multicore capabilities &ndash; whilst bringing <a href="https://tarides.com/blog/2023-07-07-making-ocaml-5-succeed-for-developers-and-organisations/">significant performance improvements</a> &ndash; can compound this problem even further.</p>
<p>In light of this, it&rsquo;s easy to see how organisations that use large numbers of co-operating servers to run big systems can struggle to narrow down even the <em>when</em> and <em>how</em> of a performance drop. Fortunately for users of OCaml, the language comes with built-in features that allow them to monitor its runtime and get automatic reports.</p>
<p>OCaml 5 introduced multicore support and, alongside it, the ring-buffer-based monitoring system <a href="https://v2.ocaml.org/releases/5.0/api/Runtime_events.html"><code>runtime_events</code></a>. From then onwards, teams have been working on adding more features, including custom events, which allows developers to monitor user events, and <a href="https://github.com/tarides/runtime_events_tools">Olly</a>, a tool providing nicely formatted data helping users to visualise program behaviour. These features make performance in OCaml easier to troubleshoot, optimise, and monitor.</p>
<h2>The Eventlog Legacy</h2>
<p>Monitoring the OCaml runtime is not a new idea, and before the 5.0 release, the language supported it via a feature called <em>Eventlog</em>. As the name suggests, <code>eventlog</code> did indeed monitor the runtime logging events to a file. This method would eventually result in massive log files that used up a lot of disk space.</p>
<p>Due to <code>eventlog</code>&rsquo;s design, it was unsuitable for long-running programs that needed to be monitored continuously for extended periods. Users had to set up their runtime in a special way to use it in the first place, and then it would still introduce a performance hit. As a result, there was a push to upgrade the feature and make it more widely applicable in conjunction with OCaml 5. Enter Eventring!</p>
<h2>Ring Buffers and Runtime Events</h2>
<p><code>Eventring</code> was the previous name for what is now called <code>runtime_events</code>. In 2021, <a href="https://tezos.com/">Tezos</a> needed more monitoring tools for the OCaml runtime, and they originally funded <a href="https://github.com/sadiqj">Sadiq Jaffer&rsquo;s</a> (then as part of <a href="https://www.opsian.com/blog/">Opsian</a>) efforts at introducing the <code>eventring</code> monitoring system. The &lsquo;ring&rsquo; part hints at the ring-buffer-based system he used to replace <code>eventlog</code>.</p>
<p>A ring buffer is a data structure that consists of two pointers in a linear backing array, where the &ldquo;<a href="https://v2.ocaml.org/manual/runtime-tracing.html">tail pointer points to a location where new events can be written and the head pointer points to the oldest event in the buffer that can be read.</a>&rdquo; When there is no more space in the array (when the tail pointer reaches the head pointer), the head pointer is advanced, and the oldest events are overwritten. When either pointer reaches the end of the array, it wraps around to the beginning.</p>
<p>The ring buffer can continuously write and overwrite data from the runtime into the array, keeping the memory used constant. This system stays lightweight and low-impact rather than creating an ever-increasing log file. When enabled, the <code>runtime_events</code> architecture introduces less than 0.5% overhead so that users can monitor their runtime continuously without performance woes.</p>
<p><code>Runtime_events</code> emits raw events, which are low-level pieces of data ready to be combined into meaningful reports by tools like Olly. There are three main types of events that <code>runtime_events</code> emits:</p>
<ul>
<li>Spans: These are events spanning a period of time, with a starting and an ending point. For example, a span beginning when a minor collection starts in the garbage collector (GC) and ending when it stops.</li>
<li>Lifecycle Events: These occur at a moment in time. For example, a lifecycle event can be emitted when a domain terminates.</li>
<li>Counters: These events include a measurement of quantity, such as the number of words promoted from the minor to the major heap during the last minor GC.</li>
</ul>
<p>These events allow developers to monitor the OCaml runtime by enabling <code>runtime_events</code> and choosing what classes of events they want to receive. You can run OCaml as usual and leave the monitoring system in the background. When something of interest happens, such as a performance drop, you can retrieve the recently emitted events from the ring buffers and examine precisely what the runtime was doing.</p>
<p>With <code>runtime_events</code>, users gain an unprecedented understanding of what the runtime environment is doing at different points of interest. With <code>runtime_events</code>, end users can expect continuous performance data extraction with very low overhead.</p>
<p>As of OCaml 5.0, this feature was exclusive to GC and runtime events, meaning user events were left out. However, the OCaml 5.1 release would change this by introducing <strong>custom events</strong>.</p>
<h2>Custom Events</h2>
<p>The addition of <code>runtime_events</code> and its spans, counters, and lifecycle events inspired <a href="https://www.lortex.org/">Lucas Pluvinage</a> to add support for custom events. Custom events are generated by the user as opposed to by OCaml itself. Custom event support allows you to generate events from <code>runtime_events</code> to see what the GC and runtime were doing when your program was active and if other user events were triggered.</p>
<p>One example of how to use custom events comes from Lucas himself. He was trying to understand some performance issues he was experiencing in a multicore Eio program. He figured out &ndash; using <code>runtime_events</code> and <code>olly</code> &ndash; that the domains had difficulty synchronising in the major GC. One domain was waiting for 200 milliseconds(!) without him being able to figure out why. But, by adding custom events of the span types in <code>eio</code>, he could see that the time was spent in a system call not marked as a blocking section. Armed with this information, Lucas could finally address the underlying issue.</p>
<p>The motivation behind this feature is to give more experienced users tools that give them greater freedom and specificity to monitor and optimise their workflows. For casual users, the three standard events (spans, counters, and lifecycle events) are great for getting a good overview of the runtime. Still, custom events allow for a more granular approach.</p>
<p>Now, adding custom events for phases of your program does help you understand how they affect the runtime and vice-versa, but that is not the only way to use them. If you wanted to, you could ignore events from the runtime entirely and only use custom events to understand what your own programs are doing. For example, how long have they been waiting for data from external services? How big are their internal queues? What kind of latency is there for each request they serve?</p>
<p>This new feature adds another dimension to the event monitoring systems for OCaml, allowing for more customised monitoring. Users can discover how aspects of their code are affecting the runtime and use the reports to optimise their programs. In turn, this benefits the rest of the ecosystem as programs become faster and more efficient. For example, the observability tool <code>eio-trace</code> (more about that at another time) uses custom events to give the user a graphical representation of what is happening with their programs &ndash; shown here tracing the Eio tutorial's networking example:</p>
<p><img src="https://tarides.com/blog/images/eio_trace-1360w~hmKPWgmBDoVOjc6OkHKvVQ.webp" sizes="(min-width: 1360px) 1360px, (min-width: 680px) 680px, 100vw" srcset="/blog/images/eio_trace-170w~pAJnWVKLqj_EdofXzL5PAw.webp 170w, /blog/images/eio_trace-340w~VMc5ReCNFkg9XDECPnk95g.webp 340w, /blog/images/eio_trace-680w~Lz_m3OYfpWG4qo16qkmUKQ.webp 680w, /blog/images/eio_trace-1360w~hmKPWgmBDoVOjc6OkHKvVQ.webp 1360w" alt="A graphical representation of the Eio tutorial's networking example"/></p>
<p>Please note that whilst custom events were introduced in OCaml 5.1, the update to the OCaml manual reflecting this change will be introduced in OCaml 5.2.</p>
<h2>Olly &amp; Observability</h2>
<p>To make these features as accessible as possible for the end user, the team working on <code>runtime_events</code> also introduced observability tooling. The observability tool for OCaml is called Olly, and it helps users visualise the data collected from <code>runtime_events</code>.</p>
<p>But more about that another time! Look out for future posts about Olly and how to use it to understand what your programs are doing. It&rsquo;s a fantastic tool that can change how you interact with your code, removing the guesswork and giving you great insight into any performance problems you encounter.</p>
<h2>Stay in Touch!</h2>
<p>If you&rsquo;re curious to explore these features and how they can benefit your workflow, you&rsquo;re in luck! We would be happy to <a href="https://tarides.com/contact/">talk to you</a> about how OCaml can benefit you and your projects and how monitoring tools can help you get the most out of your software.</p>
<p>Stay in touch with us on <a href="https://twitter.com/tarides_">X</a> (formerly known as Twitter) and on <a href="https://www.linkedin.com/company/tarides">LinkedIN</a>, where we regularly post updates about what we are working on.</p>
<h3>Acknowledgements</h3>
<p>Thank you to <a href="https://github.com/sadiqj">Sadiq Jaffer</a> and <a href="https://github.com/NickBarnes">Nick Barnes</a> for their help with this article.</p>

